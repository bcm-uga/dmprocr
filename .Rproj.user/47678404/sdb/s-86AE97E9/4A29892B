{
    "collab_server" : "",
    "contents" : "getSignature <- function(cur_met_stud, bedfiles, nbProbes) {\n  \n  genes <- bedfiles$geneSymbol\n  GenesInfo  <- lapply(1:nrow(bedfiles), function(x) getMethylInfo(met_study = cur_met_stud, txStuf = bedfiles[x, ]))\n  noprobes   <- which(sapply(GenesInfo, function(x){ is.data.frame(x$data) && nrow(x$data)==0 }))\n  genes <- genes[-noprobes]\n  GenesInfo    <- GenesInfo[-noprobes] \n  \n  \n  sapply( 1:length(GenesInfo), function(x) {\n    GenesInfo[[x]]$data <<- GenesInfo[[x]]$data[, !colSums(is.na(GenesInfo[[x]]$data)) > 0] \n  })\n  \n  \n  toRemove <- sapply(GenesInfo, function(x){\n    if(nrow(x$data) < nbProbes){\n      TRUE\n    } else{\n      FALSE\n    }\n  })\n  GenesInfo <- GenesInfo[-which(toRemove)]\n  genes <- genes[-which(toRemove)]\n  \n  \n  allProfile <- lapply(GenesInfo, function(resx){\n    GetTheProfile(resx)\n  })\n  \n}\n\n\n\nplotSignature <- function(cur_met_stud, bedfiles, nbProbes) {\n  \n  genes <- bedfiles$geneSymbol\n  GenesInfo  <- lapply(1:nrow(bedfiles), function(x) getMethylInfo(met_study = cur_met_stud, txStuf = bedfiles[x, ]))\n  noprobes   <- which(sapply(GenesInfo, function(x){ is.data.frame(x$data) && nrow(x$data)==0 }))\n  genes <- genes[-noprobes]\n  GenesInfo    <- GenesInfo[-noprobes] \n  \n  print(genes)\n  \n  sapply( 1:length(GenesInfo), function(x) {\n    GenesInfo[[x]]$data <<- GenesInfo[[x]]$data[, !colSums(is.na(GenesInfo[[x]]$data)) > 0] \n  })\n  \n  \n  toRemove <- sapply(GenesInfo, function(x){\n    if(nrow(x$data) < nbProbes){\n      TRUE\n    } else{\n      FALSE\n    }\n  })\n  GenesInfo <- GenesInfo[-which(toRemove)]\n  genes <- genes[-which(toRemove)]\n  \n  print(genes)\n  \n  allPlot <- lapply(GenesInfo, function(resx){\n    plotMethySign(resx)\n  })\n  \n}\n\n\n\n\n\n\ngetDifferentialTable <- function(met_study){\n  \n  ## get the names of ind by type\n  getTumoralRef       <- grep(\"^TCGA-.{2}-.{4}-01.{1}-.{3}-.{4}-.{2}$\", colnames(met_study$data), perl = TRUE  ,value = TRUE)\n  getControlRef       <- grep(\"^TCGA-.{2}-.{4}-11.{1}-.{3}-.{4}-.{2}$\", colnames(met_study$data), value = TRUE)\n  getOthersRef        <- grep(\"^TCGA-.{2}-.{4}-02\", colnames(met_study$data), value = TRUE)\n  \n  #delete row all na\n  ind                 <- apply(met_study$data, 1, function(x) all(is.na(x)))\n  met_study$data      <- met_study$data[!ind, ]\n  met_study$platform  <- met_study$platform[!ind, ]  \n  \n  \n  #compute the mean of Control\n  meanControl         <- rowMeans(met_study$data[, getControlRef], na.rm = TRUE)\n  \n  \n  #delete control & unwanted tum samples from data, exp_group...\n  met_study$data      <- met_study$data[, -which(colnames(met_study$data) %in% getControlRef)]\n  met_study$exp_group <- met_study$exp_group[-which(rownames(met_study$exp_group) %in% getControlRef), ] \n  \n  #met_study$data      <- met_study$data[, -which(colnames(met_study$data) %in% getOthersRef)]\n  #met_study$exp_group <- met_study$exp_group[-which(rownames(met_study$exp_group) %in% getOthersRef), ] \n  \n  \n  #compute methylation differencera between all indiv and mean control\n  list  <- lapply(colnames(met_study$data), function(x){\n    met_study$data[, x] - meanControl\n  })\n  \n  AllDM               <- do.call(cbind, list)\n  AllDM               <- as.data.frame(AllDM)\n  colnames(AllDM)     <- colnames(met_study$data)\n  rownames(AllDM)     <- rownames(met_study$data)\n  \n  #delete list 'cause it's heavy\n  rm(list)\n  \n  \n  dim(AllDM)\n  dim(met_study$exp_group)\n  dim(met_study$platform)\n  \n  \n  met_studyAllMean    <- list(data = AllDM, exp_group = met_study$exp_group, platform = met_study$platform)\n  \n  return(met_studyAllMean)\n  \n}\n\n\n\n\ngetMethylInfo <- function(met_study, txStuf) {\n  \n  strand <- txStuf[[5]]\n  \n  if(strand == \"-\"){\n    txstart <- txStuf[[4]]\n  } else{\n    txstart <- txStuf[[3]]   \n  }\n  \n  chrom <- txStuf[[2]]\n\n  probes <- met_study$platform[met_study$platform$Start < txstart + 5000 & met_study$platform$Start > txstart - 5000, ]\n  \n  probes %>% dplyr::filter(Chromosome == chrom) -> probes\n  data   <-  met_study$data[which(rownames(met_study$data) %in% probes$Composite.Element.REF), ]\n  data   <-  data[, !colSums(is.na(data)) > 0]\n  need   <- list(data = data, probes = probes, promoterPos = txstart, strand = strand, id = levels(droplevels(txStuf[[1]])) )\n  \n  return(need)\n  \n}\n\n\n#######################################################################################\noldGetTheProfile <- function(inf){\n  \n  data <- inf$data\n  probes <- inf$probes\n  n <- 1:nrow(data)\n  promoterPos <- inf$promoterPos\n  strand <- inf$strand\n\n  all <- lapply(n, function(x){\n    \n    indx       <- data[x]\n    xp         <- probes$Start[order(probes$Start)]\n    yp         <- indx[order(probes$Start), ]\n    \n    #concatenate missing bp to x axis (in order to have 10000 bp windows everytime)\n    xpA <- seq(from = promoterPos - 5000, to = min(xp)-1 )\n    xpB <- seq(from = max(xp)+1, to = promoterPos + 5000)\n    xp  <- c(xpA, xp, xpB) \n   \n    \n    #add fictiv value to added bp in y axis\n    yp  <- c( rep(0, length(xpA)), yp, rep(0, length(xpB)) )\n    \n    ######\n    xf         <- seq(min(probes$Start), max(probes$Start), by = 10)\n    yf         <- pchip(xp, yp, xf)\n    \n    \n    ## re-extract only the maximum interval between two probes\n    indFinal <- which(xf >= min(probes$Start) & xf <= max(probes$Start))\n    xf <- xf[indFinal]\n    yf <- yf[indFinal]\n    \n    \n    if(strand == \"-\"){\n      xf <- 0 + (promoterPos - xf)\n    } else {\n      xf <- 0 - (promoterPos - xf)  \n    }  \n    \n    xf <- xf/2500\n    \n    bigStacked <- data.frame(position = xf, valuesInter = yf, ind = rep(names(indx), length(xf)))\n    \n  })\n  big          <- do.call(rbind, all)\n  \n  meanOfInter <- aggregate(big[, 2], list(big$position), mean)\n  varOfInter <- aggregate(big[, 2], list(big$position), var)\n  colnames(meanOfInter) <- c(\"x\", \"y\")\n  meanOfInter$var <- varOfInter[, 2]\n  \n  \n  #########build the density vector\n  \n  #get the position of probes again\n  xold <- probes$Start\n  if(strand == \"-\"){\n    xold <- 0 + (promoterPos - xold)\n  } else {\n    xold <- 0 - (promoterPos - xold)\n  }\n  \n  xold <-xold / 2500\n  x <- meanOfInter$x\n  \n  #vector of interpolation + position of probes\n  xxold <- sort(c(xold, x))\n  \n  #find index of old in bigvect\n  indx <- match(xold, xxold) \n  \n  #find index of point +-20 around a probes position \n  indxAround <- lapply(indx,  function(x) x + -20:20) %>% unlist() %>% intersect(seq_along(xxold))\n  \n  #initialized empty vector\n  A <- double(length(xxold))\n  \n  #Give value to empty A vector\n  A[indxAround] <- 1\n  \n  #delete xold from x2 with the indx\n  A <- A[-indx]\n  \n  meanOfInter$pond <- A\n  \n  return(meanOfInter)\n  \n}  \n\n\n\n#GetTheProfile(tmpinf$data, probes = tmpinf$probes, n = 1:nrow(tmpinf$data), promoterPos = tmpinf$promoterPos, strand = tmpinf$strand)\n#becomes\n#GetTheProfile(inf)\n#######################################################################################\nGetTheProfile <- function(inf){\n  \n  #data <- inf$data\n  probes <- inf$probes\n  n <- seq_along(inf$data)\n  promoterPos <- inf$promoterPos\n  strand <- inf$strand\n  \n  all <- lapply(n, function(x){\n    \n    indx       <- inf$data[x]\n    xp         <- probes$Start[order(probes$Start)]\n    yp         <- indx[order(probes$Start), ]\n    \n    #concatenate missing bp to x axis (in order to have 10000 bp windows everytime)\n    xpA <- seq(from = promoterPos - 5000, to = min(xp)-1 )\n    xpB <- seq(from = max(xp)+1, to = promoterPos + 5000)\n    xp  <- c(xpA, xp, xpB) \n    \n    #add fictiv value to added bp in y axis\n    yp  <- c( rep(0, length(xpA)), yp, rep(0, length(xpB)) )\n    \n    ######\n    xf         <- seq(promoterPos - 5000, promoterPos + 5000, by = 20)\n    yf         <- pchip(xp, yp, xf)\n    \n    \n    ## re-extract only the maximum interval between two probes\n    # indFinal <- which(xf >= min(probes$Start) & xf <= max(probes$Start))\n    # xf <- xf[indFinal]\n    # yf <- yf[indFinal]\n    \n    \n    if(strand == \"-\"){\n      xf <- 0 + (promoterPos - xf)\n    } else {\n      xf <- 0 - (promoterPos - xf)  \n    }  \n    \n    xf <- xf/2500\n    \n    bigStacked <- data.frame(position = xf, valuesInter = yf, ind = rep(names(indx), length(xf)))\n    \n  })\n  big          <- do.call(rbind, all)\n  \n  meanOfInter <- aggregate(big[, 2], list(big$position), mean)\n  varOfInter <- aggregate(big[, 2], list(big$position), var)\n  colnames(meanOfInter) <- c(\"x\", \"y\")\n  meanOfInter$var <- varOfInter[, 2]\n  \n  \n  #########build the density vector\n  \n  #get the position of probes again\n  xold <- probes$Start\n  if(strand == \"-\"){\n    xold <- 0 + (promoterPos - xold)\n  } else {\n    xold <- 0 - (promoterPos - xold)\n  }\n  \n  xold <-xold / 2500\n  x <- meanOfInter$x\n  \n  #vector of interpolation + position of probes\n  xxold <- sort(c(xold, x))\n  \n  #find index of old in bigvect\n  indx <- match(xold, xxold) \n  \n  #find index of point +-20 around a probes position \n  indxAround <- lapply(indx,  function(x) x + -20:20) %>% unlist() %>% intersect(seq_along(xxold))\n  \n  #initialized empty vector\n  A <- double(length(xxold))\n  \n  #Give value to empty A vector\n  A[indxAround] <- 1\n  \n  #delete xold from x2 with the indx\n  A <- A[-indx]\n  \n  A[which(meanOfInter$y == \"0\")] <- 0 \n  \n  meanOfInter$pond <- A\n  meanOfInter$id   <- rep(inf$id, length(meanOfInter$pond)) \n  \n  return(meanOfInter)\n  \n}  \n\n\n\n\n\nplotMethySign <- function(inf){\n  \n  data <- inf$data\n  probes <- inf$probes\n  n <- 1:nrow(data)\n  promoterPos <- inf$promoterPos\n  strand <- inf$strand\n  \n  ##### the light version\n  \n  stackedData           <- stack(data[n])\n  stackedData$position  <- rep(probes$Start, length(n))\n  stackedData$Feature   <- rep(probes$Feature_Type, length(n))\n  stackedData$probeName <- rep(probes$Composite.Element.REF, length(n))\n  \n  if(strand == \"-\"){\n    stackedData$position <- 0 + (promoterPos - stackedData$position)\n  } else {\n    stackedData$position <- 0 - (promoterPos - stackedData$position)  \n  }  \n  \n  stackedData$position <- stackedData$position/2500\n  \n  ############################## interpolation and smoothing\n  #####do the big version\n  nbseq = 10000\n  all <- lapply(n, function(x, seqnb = nbseq){\n    \n    indx       <- data[x]\n    xp         <- probes$Start[order(probes$Start)]\n    yp         <- indx[order(probes$Start), ]\n    \n    #concatenate missing bp to x axis (in order to have 10000 bp windows everytime)\n    xpA <- seq(from = promoterPos - 5000, to = min(xp)-1 )\n    xpB <- seq(from = max(xp)+1, to = promoterPos + 5000)\n    xp  <- c(xpA, xp, xpB) \n    \n    #add fictiv value to added bp in y axis\n    yp  <- c( rep(0, length(xpA)), yp, rep(0, length(xpB)) )\n    \n    ######\n    xf         <- seq(min(probes$Start), max(probes$Start), by = 1)\n    yf         <- pchip(xp, yp, xf)\n    \n    \n    \n    ## re-extract only the maximum interval between two probes\n    indFinal <- which(xf >= min(probes$Start) & xf <= max(probes$Start))\n    xf <- xf[indFinal]\n    yf <- yf[indFinal]\n    \n    if(strand == \"-\"){\n      xf <- 0 + (promoterPos - xf)\n    } else {\n      xf <- 0 - (promoterPos - xf)  \n    }  \n    \n    xf <- xf/2500\n    \n    bigStacked <- data.frame(position = xf, valuesInter = yf, ind = rep(names(indx), length(xf)))\n    \n  })\n  big          <- do.call(rbind, all)\n  \n  meanOfInter <- aggregate(big[, 2], list(big$position), mean)\n  sdOfInter <- aggregate(big[, 2], list(big$position), sd)\n  colnames(meanOfInter) <- c(\"x\", \"y\")\n  meanOfInter$sd <- sdOfInter[, 2]\n  \n  \n\n  p1 <- ggplot() +\n    geom_point(data=stackedData, aes( x = position, y = values, colour = ind), size = 0.8) +\n    geom_line(data = meanOfInter, aes(x = x, y= y), size = 0.5, alpha = 0.7) +\n    geom_ribbon(data = meanOfInter, aes(x= x, ymin= y - sd, ymax= y + sd), fill = \"grey70\", alpha = 0.8) +\n    #theme\n    geom_vline(xintercept = 0, alpha = 0.8) +\n    geom_hline(yintercept = 0, alpha= 0.8) + \n    coord_cartesian(ylim = c(-1,1), xlim = c(-2, 2)) +\n    theme(legend.position=\"none\")  \n} \n\n\nplotProfile <- function(profileList){\n  \n  lapply(profileList, function(profile){\n    \n    profile$sd <- sqrt(profile$var)\n  \n    p1 <- ggplot() +\n      geom_line(data = profile, aes(x = x, y= y), size = 0.5, color = \"red\") +\n      geom_ribbon(data = profile, aes(x= x, ymin= y - sd, ymax= y + sd), fill = \"grey70\", alpha = 0.8) +\n      #theme\n      geom_vline(xintercept = 0, alpha = 0.8) +\n      geom_hline(yintercept = 0, alpha= 0.8) + \n      coord_cartesian(ylim = c(-1,1), xlim = c(-2, 2)) +\n      theme(legend.position=\"none\") +\n      ggtitle(profile$id[1])\n  \n  })\n  \n}\n\n\n\neucli.dist <- function(m1, m2){ #where m1 and m2 are methylation profile\n   ##here we go, first the distance\n    D.probe <-  (m1$y - m2$y)^2 / (m1$var + m2$var)\n\n   ##then the moderation\n    D.gene  <- sum(D.probe * m1$pond * m2$pond, na.rm = TRUE) / sum(m1$pond * m2$pond, na.rm = TRUE)\n    \n    return(D.gene)\n       \n}\n\n\n\nsign_Distance <- function(signList, frechet = FALSE){\n  \n  #create empty matrix\n  m <- matrix(nrow = length(signList), ncol = length(signList))\n  \n  for(i in 1:length(signList)){ \n    \n    for(j in 1:length(signList)){\n      m1 <- signList[[i]]  \n      m2 <- signList[[j]]\n      \n      \n      if(frechet){\n        \n        frech.dist <- distFrechet(Px = m1$x, Py = m1$y, Qx = m2$x, Qy = m2$y)          \n        m[i,j] <- frech.dist\n        \n      }else {\n        \n        m[i,j] <- sqrt(eucli.dist(m1, m2))\n        \n      }\n      \n    }     \n  } \n  return(m)\n}",
    "created" : 1497346415473.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2222264030",
    "id" : "4A29892B",
    "lastKnownWriteTime" : 1497270433,
    "last_content_update" : 1497270433,
    "path" : "~/Documents/Data/epilung/results/functions/methyl_sign_functions.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}